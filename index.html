<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Acrylic Color Mixer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .font-inter {
            font-family: 'Inter', sans-serif;
        }
        #imageCanvas {
            cursor: crosshair;
            width: 100%; /* Canvas width will be set by JS, this is a fallback */
            height: auto; /* Canvas height will be set by JS */
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            touch-action: none; /* Prevent default touch actions like scrolling when panning */
        }
        #cameraStream {
            width: 100%;
            max-height: 400px;
            height: auto;
            border-radius: 0.5rem;
            border: 1px solid #d1d5db;
            background-color: #000;
        }
        .color-swatch {
            width: 50px;
            height: 50px;
            border-radius: 0.375rem;
            border: 1px solid #9ca3af;
            display: inline-block;
            vertical-align: middle;
        }
        .paint-swatch {
            width: 20px;
            height: 20px;
            border-radius: 0.25rem;
            border: 1px solid #9ca3af;
            display: inline-block;
            vertical-align: middle;
            margin-right: 8px;
        }
        .modal {
            display: none; position: fixed; z-index: 1000;
            left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe; margin: 15% auto; padding: 20px;
            border: 1px solid #888; width: 80%; max-width: 500px;
            border-radius: 0.5rem; text-align: center;
        }
        .modal-close-button {
            color: #aaa; float: right; font-size: 28px; font-weight: bold;
        }
        .modal-close-button:hover, .modal-close-button:focus {
            color: black; text-decoration: none; cursor: pointer;
        }
        .loader {
            border: 5px solid #f3f3f3; border-top: 5px solid #3498db;
            border-radius: 50%; width: 40px; height: 40px;
            animation: spin 1s linear infinite; margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .zoom-button {
            padding: 0.5rem 0.75rem; /* py-2 px-3 */
            background-color: #e5e7eb; /* bg-gray-200 */
            color: #374151; /* text-gray-700 */
            font-semibold;
            border-radius: 0.375rem; /* rounded-md */
            transition: background-color 0.15s ease-in-out;
        }
        .zoom-button:hover {
            background-color: #d1d5db; /* hover:bg-gray-300 */
        }
        .zoom-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4 font-inter">

    <div class="bg-white p-6 sm:p-8 rounded-xl shadow-2xl w-full max-w-2xl">
        <header class="mb-6 text-center">
            <h1 class="text-3xl font-bold text-gray-800">Acrylic Color Mixer</h1>
            <p class="text-sm text-gray-600 mt-2">Upload an image, pick a color, and get a Winsor & Newton acrylic paint mixing suggestion.</p>
        </header>

        <div id="imageInputSection">
            <div id="fileUploadSection" class="mb-4">
                <label for="imageUpload" class="block text-sm font-medium text-gray-700 mb-1">Upload Image:</label>
                <input type="file" id="imageUpload" accept="image/*" class="block w-full text-sm text-gray-900 bg-gray-50 rounded-lg border border-gray-300 cursor-pointer focus:outline-none focus:border-blue-500 p-2.5">
            </div>
            <div class="text-center my-3"><span class="text-gray-500 text-sm">OR</span></div>
            <button id="useCameraButton" class="w-full bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 transition duration-150 ease-in-out mb-4">Use Camera</button>
        </div>

        <div id="cameraView" class="hidden mb-4">
            <video id="cameraStream" playsinline autoplay muted class="mb-2"></video>
            <button id="takePhotoButton" class="w-full bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md">Take Photo</button>
            <button id="cancelCameraButton" class="w-full bg-gray-400 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md mt-2">Cancel Camera</button>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <div>
                <h2 class="text-lg font-semibold text-gray-700 mb-2">Image Preview:</h2>
                <canvas id="imageCanvas" class="bg-gray-200"></canvas>
                <div class="flex justify-center items-center space-x-2 my-2">
                    <button id="zoomOutButton" title="Zoom Out" class="zoom-button" disabled>-</button>
                    <button id="zoomInButton" title="Zoom In" class="zoom-button" disabled>+</button>
                    <button id="resetZoomButton" title="Reset Zoom" class="zoom-button" disabled>Reset</button>
                </div>
                <p id="canvasHelperText" class="text-xs text-gray-500 mt-1 text-center">Upload an image or use camera. Drag to pan when zoomed.</p>
            </div>
            <div>
                <h2 class="text-lg font-semibold text-gray-700 mb-2">Selected Color:</h2>
                <div id="selectedColorInfo" class="p-4 bg-gray-50 rounded-lg border border-gray-200 min-h-[100px] flex items-center justify-center">
                    <span class="text-gray-500">No color selected</span>
                </div>
                <button id="findMixButton" class="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md disabled:opacity-50" disabled>Find Paint Mix</button>
            </div>
        </div>

        <div class="mb-4">
            <h2 class="text-lg font-semibold text-gray-700 mb-2">Suggested Paint Mix:</h2>
            <div id="mixingResult" class="p-4 bg-gray-50 rounded-lg border border-gray-200 min-h-[120px]">
                <p class="text-gray-500">Upload an image and select a color to see suggestions.</p>
            </div>
        </div>
        <div class="mt-6 p-3 bg-yellow-50 border border-yellow-300 rounded-lg text-yellow-700 text-xs">
            <p><strong>Disclaimer:</strong> Paint data and mixing simulations are approximations. Actual paint mixing results may vary.</p>
        </div>
    </div>

    <div id="loadingModal" class="modal"><div class="modal-content"><p class="text-lg font-semibold mb-2">Calculating Mix...</p><div class="loader"></div><p class="text-sm text-gray-600">This might take a moment.</p></div></div>

    <script>
        // --- DOM Elements ---
        const imageUpload = document.getElementById('imageUpload');
        const imageCanvas = document.getElementById('imageCanvas');
        const canvasCtx = imageCanvas.getContext('2d');
        const selectedColorInfo = document.getElementById('selectedColorInfo');
        const findMixButton = document.getElementById('findMixButton');
        const mixingResult = document.getElementById('mixingResult');
        const canvasHelperText = document.getElementById('canvasHelperText');
        const loadingModal = document.getElementById('loadingModal');
        const imageInputSection = document.getElementById('imageInputSection');
        const useCameraButton = document.getElementById('useCameraButton');
        const cameraView = document.getElementById('cameraView');
        const cameraStreamElement = document.getElementById('cameraStream');
        const takePhotoButton = document.getElementById('takePhotoButton');
        const cancelCameraButton = document.getElementById('cancelCameraButton');
        const zoomInButton = document.getElementById('zoomInButton');
        const zoomOutButton = document.getElementById('zoomOutButton');
        const resetZoomButton = document.getElementById('resetZoomButton');

        let stream = null;
        let currentImage = null;
        let selectedRgb = null;

        // --- Zoom and Pan State ---
        let zoomLevel = 1.0;
        let initialFitZoom = 1.0; // Zoom level to fit the image initially
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let lastPanPosition = { x: 0, y: 0 };
        const MIN_ZOOM = 0.1; // Minimum zoom level
        const MAX_ZOOM = 10.0; // Maximum zoom level
        const ZOOM_SENSITIVITY = 1.2;


        // --- Paint Database (From User Provided File - Updated) ---
        const WINSOR_NEWTON_ACRYLICS = [
            { name: "Pro Titanium White", rgb: { r: 223, g: 221, b: 217 } }, //rgb(223, 221, 217)
            { name: "Pro Cadmium Yellow Light", rgb: { r: 222, g: 194, b: 3 } }, //rgb(222, 194, 3)
            { name: "Galeria Cadmium Yellow Medium Hue", rgb: { r: 249, g: 197, b: 0 } }, //rgb(249, 197, 0)
            { name: "Galeria Yellow Ochre", rgb: { r: 166, g: 115, b: 19 } }, //rgb(166, 115, 19)
            { name: "Pro Raw Sienna", rgb: { r: 122, g: 81, b: 46 } }, //rgb(122, 81, 46)
            { name: "Galeria Raw Sienna", rgb: { r: 114, g: 61, b: 23 } }, //rgb(114, 61, 23)
            { name: "Pro Cadmium Red Light", rgb: { r: 217, g: 53, b: 28 } }, //rgb(217, 53, 28)
            { name: "Galeria Permanent Alizarin Crimson", rgb: { r: 137, g: 11, b: 24 } }, //rgb(137, 11, 24)
            { name: "Pro Cerulean Blue", rgb: { r: 1, g: 100, b: 184 } }, //rgb(1, 100, 184)
            { name: "Pro Phthalo Blue (Green Shade)", rgb: { r: 21, g: 26, b: 52 } },
            { name: "Galeria Phthalo Blue", rgb: { r: 6, g: 2, b: 5 } }, //rgb(6, 2, 5)
            { name: "Pro Phthalo Blue (Red Shade)", rgb: { r: 27, g: 28, b: 49 } },
            { name: "Pro Ultramarine Blue", rgb: { r: 2, g: 38, b: 150 } },
            { name: "Galeria Payne's Gray", rgb: { r: 32, g: 34, b: 38 } },
            { name: "Pro Mixing White", rgb: { r: 225, g: 223, b: 218 } },
        ];


        // --- Event Listeners ---
        imageUpload.addEventListener('change', handleImageUpload);
        imageCanvas.addEventListener('click', handleCanvasClick);
        findMixButton.addEventListener('click', handleFindMix);
        useCameraButton.addEventListener('click', startCamera);
        takePhotoButton.addEventListener('click', takePhoto);
        cancelCameraButton.addEventListener('click', cancelCamera);
        zoomInButton.addEventListener('click', handleZoomIn);
        zoomOutButton.addEventListener('click', handleZoomOut);
        resetZoomButton.addEventListener('click', handleResetZoom);

        // Pan event listeners
        imageCanvas.addEventListener('mousedown', startPan);
        imageCanvas.addEventListener('mousemove', panImage);
        imageCanvas.addEventListener('mouseup', endPan);
        imageCanvas.addEventListener('mouseleave', endPan);
        imageCanvas.addEventListener('touchstart', startPan, { passive: false });
        imageCanvas.addEventListener('touchmove', panImage, { passive: false });
        imageCanvas.addEventListener('touchend', endPan);
        imageCanvas.addEventListener('touchcancel', endPan);


        // --- Canvas Sizing and Initial Placeholder ---
        function setCanvasDimensions() {
            const parentElement = imageCanvas.parentElement;
            if (!parentElement) return;
            const parentWidth = parentElement.clientWidth;
            imageCanvas.width = parentWidth > 0 ? parentWidth : 300; // Use full parent width
            imageCanvas.height = imageCanvas.width * (2 / 3); // Maintain a 3:2 aspect ratio
        }

        function drawInitialCanvasPlaceholder() {
            setCanvasDimensions(); // Ensure canvas dimensions are set
            canvasCtx.fillStyle = '#e5e7eb'; // bg-gray-200
            canvasCtx.fillRect(0, 0, imageCanvas.width, imageCanvas.height);
            canvasCtx.fillStyle = '#9ca3af'; // text-gray-400
            canvasCtx.textAlign = 'center';
            canvasCtx.textBaseline = 'middle';
            canvasCtx.font = '14px Inter';
            wrapText(canvasCtx, 'Upload an image or use camera. Drag to pan when zoomed.', imageCanvas.width / 2, imageCanvas.height / 2, imageCanvas.width - 20, 18);
            updateZoomButtons();
        }
        
        window.addEventListener('resize', () => {
            setCanvasDimensions();
            if (currentImage) {
                calculateInitialZoomAndPan(); // Recalculate fit zoom for new canvas size
                redrawImageWithZoomAndPan();
            } else {
                drawInitialCanvasPlaceholder();
            }
        });

        // --- Image Loading and Processing ---
        function loadImageOnCanvas(imageSrc) {
            currentImage = new Image();
            currentImage.onload = () => {
                setCanvasDimensions(); // Ensure canvas dimensions are correct before calculating zoom
                calculateInitialZoomAndPan();
                redrawImageWithZoomAndPan();
                
                selectedColorInfo.innerHTML = '<span class="text-gray-500">Click image to pick color</span>';
                selectedRgb = null;
                findMixButton.disabled = true;
                mixingResult.innerHTML = '<p class="text-gray-500">Pick a color to see suggestions.</p>';
                canvasHelperText.textContent = 'Click to pick color. Drag to pan when zoomed.';
                
                cameraView.classList.add('hidden');
                imageInputSection.classList.remove('hidden');
                stopCameraStream();
                updateZoomButtons();
            };
            currentImage.onerror = () => {
                canvasHelperText.textContent = 'Error loading image.';
                alertUser('Error: Could not load the image. Please try again.');
                currentImage = null; // Reset current image
                updateZoomButtons(); // Disable zoom buttons
                drawInitialCanvasPlaceholder(); // Show placeholder
            };
            currentImage.src = imageSrc;
        }

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => loadImageOnCanvas(e.target.result);
                reader.readAsDataURL(file);
            }
        }

        // --- Camera Handling ---
        async function startCamera() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                try {
                    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                    cameraStreamElement.srcObject = stream;
                    imageInputSection.classList.add('hidden');
                    cameraView.classList.remove('hidden');
                    canvasHelperText.textContent = 'Position camera and take photo.';
                } catch (err) {
                    try { // Fallback
                        stream = await navigator.mediaDevices.getUserMedia({ video: true });
                        cameraStreamElement.srcObject = stream;
                        imageInputSection.classList.add('hidden');
                        cameraView.classList.remove('hidden');
                    } catch (fallbackErr) {
                         alertUser("Could not access camera. Ensure permissions are granted.");
                         cancelCamera(); // Revert UI
                    }
                }
            } else {
                alertUser("Camera API not supported. Please upload a file.");
            }
        }

        function takePhoto() {
            if (!stream || !cameraStreamElement.videoWidth) {
                alertUser("Camera not ready."); return;
            }
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = cameraStreamElement.videoWidth;
            tempCanvas.height = cameraStreamElement.videoHeight;
            tempCanvas.getContext('2d').drawImage(cameraStreamElement, 0, 0, tempCanvas.width, tempCanvas.height);
            loadImageOnCanvas(tempCanvas.toDataURL('image/png'));
        }

        function stopCameraStream() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
                cameraStreamElement.srcObject = null;
            }
        }

        function cancelCamera() {
            stopCameraStream();
            cameraView.classList.add('hidden');
            imageInputSection.classList.remove('hidden');
            if (!currentImage) {
                 drawInitialCanvasPlaceholder();
                 canvasHelperText.textContent = 'Upload an image or use camera. Drag to pan when zoomed.';
            } else {
                 canvasHelperText.textContent = 'Click to pick color. Drag to pan when zoomed.';
            }
        }

        // --- Zoom and Pan Logic ---
        function calculateInitialZoomAndPan() {
            if (!currentImage || !imageCanvas.width || !imageCanvas.height || imageCanvas.width === 0 || imageCanvas.height === 0) {
                initialFitZoom = 1.0;
                zoomLevel = 1.0;
                panX = 0;
                panY = 0;
                return;
            }
            const canvasAspect = imageCanvas.width / imageCanvas.height;
            const imageAspect = currentImage.width / currentImage.height;

            if (imageAspect > canvasAspect) { // Image is wider than canvas aspect ratio
                initialFitZoom = imageCanvas.width / currentImage.width;
            } else { // Image is taller or same aspect ratio
                initialFitZoom = imageCanvas.height / currentImage.height;
            }
            initialFitZoom = Math.max(MIN_ZOOM, initialFitZoom); // Ensure not too small

            zoomLevel = initialFitZoom;
            panX = 0; // Centering is handled by redrawImageWithZoomAndPan
            panY = 0;
        }

        function redrawImageWithZoomAndPan() {
            if (!imageCanvas.width || !imageCanvas.height) return; // Canvas not ready

            canvasCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
            canvasCtx.fillStyle = '#f0f0f0'; // Light gray background
            canvasCtx.fillRect(0, 0, imageCanvas.width, imageCanvas.height);

            if (!currentImage) {
                drawInitialCanvasPlaceholder(); // Or just leave background if preferred
                updateZoomButtons();
                return;
            }

            // Calculate the dimensions of the portion of the source image to display
            let sWidth = imageCanvas.width / zoomLevel;
            let sHeight = imageCanvas.height / zoomLevel;

            // Clamp panX and panY to keep the viewport within the source image boundaries
            panX = Math.max(0, Math.min(panX, currentImage.width - sWidth));
            panY = Math.max(0, Math.min(panY, currentImage.height - sHeight));
            
            // If image is smaller than viewport at current zoom, center it
            let finalSX = panX, finalSY = panY;
            let finalSWidth = sWidth, finalSHeight = sHeight;
            let finalDX = 0, finalDY = 0;
            let finalDWidth = imageCanvas.width, finalDHeight = imageCanvas.height;

            if (currentImage.width * zoomLevel < imageCanvas.width) { // Image is effectively narrower
                finalSWidth = currentImage.width; // Source uses full image width
                finalSX = 0;
                finalDWidth = currentImage.width * zoomLevel; // Drawn width is scaled image width
                finalDX = (imageCanvas.width - finalDWidth) / 2; // Center horizontally
            }
            if (currentImage.height * zoomLevel < imageCanvas.height) { // Image is effectively shorter
                finalSHeight = currentImage.height; // Source uses full image height
                finalSY = 0;
                finalDHeight = currentImage.height * zoomLevel; // Drawn height is scaled image height
                finalDY = (imageCanvas.height - finalDHeight) / 2; // Center vertically
            }
            
            // Prevent drawing outside image bounds if sWidth/sHeight were clamped due to pan
            if (finalSX + finalSWidth > currentImage.width) finalSWidth = currentImage.width - finalSX;
            if (finalSY + finalSHeight > currentImage.height) finalSHeight = currentImage.height - finalSY;


            canvasCtx.drawImage(
                currentImage,
                finalSX, finalSY, finalSWidth, finalSHeight,
                finalDX, finalDY, finalDWidth, finalDHeight
            );
            updateZoomButtons();
        }
        
        function handleZoomIn() {
            if (!currentImage) return;
            const newZoomLevel = Math.min(MAX_ZOOM, zoomLevel * ZOOM_SENSITIVITY);
            applyZoom(newZoomLevel);
        }

        function handleZoomOut() {
            if (!currentImage) return;
            // Allow zooming out slightly beyond initial fit, but not less than MIN_ZOOM
            const newZoomLevel = Math.max(MIN_ZOOM, zoomLevel / ZOOM_SENSITIVITY);
            applyZoom(newZoomLevel);
        }
        
        function applyZoom(newZoomLevel) {
            if (!currentImage || !imageCanvas.width || !imageCanvas.height) return;

            // Calculate center of current view on the source image
            const currentViewCenterX = panX + (imageCanvas.width / zoomLevel) / 2;
            const currentViewCenterY = panY + (imageCanvas.height / zoomLevel) / 2;

            zoomLevel = newZoomLevel;

            // Adjust pan to keep the same center point
            panX = currentViewCenterX - (imageCanvas.width / zoomLevel) / 2;
            panY = currentViewCenterY - (imageCanvas.height / zoomLevel) / 2;
            
            redrawImageWithZoomAndPan();
        }

        function handleResetZoom() {
            if (!currentImage) return;
            calculateInitialZoomAndPan(); // Resets zoomLevel to initialFitZoom and panX/Y to 0
            redrawImageWithZoomAndPan();
        }

        function updateZoomButtons() {
            const hasImage = !!currentImage;
            zoomInButton.disabled = !hasImage || zoomLevel >= MAX_ZOOM;
            zoomOutButton.disabled = !hasImage || zoomLevel <= MIN_ZOOM; // Or zoomLevel <= initialFitZoom if we don't want to zoom out further
            resetZoomButton.disabled = !hasImage;
        }

        function getEventPosition(event) {
            const rect = imageCanvas.getBoundingClientRect();
            if (event.touches && event.touches.length > 0) {
                return { x: event.touches[0].clientX - rect.left, y: event.touches[0].clientY - rect.top };
            }
            return { x: event.clientX - rect.left, y: event.clientY - rect.top };
        }

        function startPan(event) {
            if (!currentImage || zoomLevel <= initialFitZoom + 0.01) { // Allow panning only if significantly zoomed in
                isPanning = false;
                return;
            }
            if (event.cancelable) event.preventDefault(); // Prevent page scroll on touch
            isPanning = true;
            lastPanPosition = getEventPosition(event);
            imageCanvas.style.cursor = 'grabbing';
        }

        function panImage(event) {
            if (!isPanning || !currentImage) return;
            if (event.cancelable) event.preventDefault();

            const currentPosition = getEventPosition(event);
            const deltaX = currentPosition.x - lastPanPosition.x;
            const deltaY = currentPosition.y - lastPanPosition.y;

            panX -= deltaX / zoomLevel;
            panY -= deltaY / zoomLevel;

            lastPanPosition = currentPosition;
            redrawImageWithZoomAndPan();
        }

        function endPan() {
            if (!isPanning) return;
            isPanning = false;
            imageCanvas.style.cursor = 'crosshair';
        }


        // --- Color Picking ---
        function handleCanvasClick(event) {
            if (isPanning || !currentImage) return; // Don't pick color if panning action just ended or no image

            const pos = getEventPosition(event);
            const x = pos.x;
            const y = pos.y;

            // Check if click is within the drawn image area on canvas, especially if image is centered and smaller than canvas
            let drawnImageRect = { x:0, y:0, width: imageCanvas.width, height: imageCanvas.height };
            if (currentImage.width * zoomLevel < imageCanvas.width) {
                drawnImageRect.width = currentImage.width * zoomLevel;
                drawnImageRect.x = (imageCanvas.width - drawnImageRect.width) / 2;
            }
            if (currentImage.height * zoomLevel < imageCanvas.height) {
                drawnImageRect.height = currentImage.height * zoomLevel;
                drawnImageRect.y = (imageCanvas.height - drawnImageRect.height) / 2;
            }

            if (x < drawnImageRect.x || x > drawnImageRect.x + drawnImageRect.width ||
                y < drawnImageRect.y || y > drawnImageRect.y + drawnImageRect.height) {
                // Clicked outside the actual image area (e.g., on the gray background)
                return;
            }

            const pixelData = canvasCtx.getImageData(x, y, 1, 1).data;
            selectedRgb = { r: pixelData[0], g: pixelData[1], b: pixelData[2] };

            selectedColorInfo.innerHTML = `
                <div class="flex items-center">
                    <span class="color-swatch mr-3" style="background-color: rgb(${selectedRgb.r}, ${selectedRgb.g}, ${selectedRgb.b});"></span>
                    <div>
                        <p class="font-semibold text-gray-800">RGB: (${selectedRgb.r}, ${selectedRgb.g}, ${selectedRgb.b})</p>
                        <p class="text-sm text-gray-600">Hex: #${rgbToHex(selectedRgb.r, selectedRgb.g, selectedRgb.b)}</p>
                    </div>
                </div>`;
            findMixButton.disabled = false;
            mixingResult.innerHTML = '<p class="text-gray-500">Click "Find Paint Mix" to get suggestions.</p>';
        }

        // --- Color Mixing Logic (simplified, remains the same) ---
        async function handleFindMix() {
            if (!selectedRgb) { alertUser("Please select a color from the image first."); return; }
            showLoadingModal(true);
            mixingResult.innerHTML = '<p class="text-gray-600">Calculating best mix...</p>';
            await new Promise(resolve => setTimeout(resolve, 50));
            try {
                const bestMix = findClosestPaintMix(selectedRgb);
                displayMixResult(bestMix);
            } catch (error) {
                console.error("Error finding mix:", error);
                mixingResult.innerHTML = '<p class="text-red-500">Error calculating mix.</p>';
                alertUser(`An error occurred: ${error.message}`);
            } finally { showLoadingModal(false); }
        }
        function colorDiff(rgb1, rgb2) { /* ... */ const dr = rgb1.r - rgb2.r; const dg = rgb1.g - rgb2.g; const db = rgb1.b - rgb2.b; return Math.sqrt(dr * dr + dg * dg + db * db); }
        function mixTwoColors(c1, r1, c2, r2) { /* ... */ const t = r1+r2; if(t===0)return{r:0,g:0,b:0}; return {r:Math.round((c1.rgb.r*r1+c2.rgb.r*r2)/t), g:Math.round((c1.rgb.g*r1+c2.rgb.g*r2)/t), b:Math.round((c1.rgb.b*r1+c2.rgb.b*r2)/t)};}
        function mixThreeColors(c1,r1,c2,r2,c3,r3){ /* ... */ const t=r1+r2+r3; if(t===0)return{r:0,g:0,b:0}; return {r:Math.round((c1.rgb.r*r1+c2.rgb.r*r2+c3.rgb.r*r3)/t),g:Math.round((c1.rgb.g*r1+c2.rgb.g*r2+c3.rgb.g*r3)/t),b:Math.round((c1.rgb.b*r1+c2.rgb.b*r2+c3.rgb.b*r3)/t)};}
        function findClosestPaintMix(targetRgb) {
            let bestMatch = { paintNames: [], mixedRgb: null, diff: Infinity, recipe: "" };
            WINSOR_NEWTON_ACRYLICS.forEach(p => { const d = colorDiff(targetRgb, p.rgb); if (d < bestMatch.diff) bestMatch = { paintNames: [p.name], mixedRgb: p.rgb, diff: d, recipe: `1 part ${p.name}` }; });
            const ratios = [{r1:1,r2:3},{r1:1,r2:2},{r1:1,r2:1},{r1:2,r2:1},{r1:3,r2:1}];
            for(let i=0;i<WINSOR_NEWTON_ACRYLICS.length;i++){ for(let j=i+1;j<WINSOR_NEWTON_ACRYLICS.length;j++){
                const p1=WINSOR_NEWTON_ACRYLICS[i], p2=WINSOR_NEWTON_ACRYLICS[j];
                ratios.forEach(r => {
                    [{c1:p1,rat1:r.r1,c2:p2,rat2:r.r2}, {c1:p1,rat1:r.r2,c2:p2,rat2:r.r1}].forEach(o => {
                        if (o.rat1 === r.r1 && o.rat2 === r.r2 && r.r1 === r.r2 && o.c1 === p1 && o.c2 === p2) { /* skip redundant for 1:1 and same order */ } else {
                            const m=mixTwoColors(o.c1,o.rat1,o.c2,o.rat2), d=colorDiff(targetRgb,m);
                            if(d<bestMatch.diff) bestMatch={paintNames:[o.c1.name,o.c2.name],mixedRgb:m,diff:d,recipe:`${o.rat1} part(s) ${o.c1.name} + ${o.rat2} part(s) ${o.c2.name}`};
                        }
                    });
                });
            }}
            if(WINSOR_NEWTON_ACRYLICS.length>=3){ for(let i=0;i<WINSOR_NEWTON_ACRYLICS.length;i++){ for(let j=i+1;j<WINSOR_NEWTON_ACRYLICS.length;j++){ for(let k=j+1;k<WINSOR_NEWTON_ACRYLICS.length;k++){
                const p1=WINSOR_NEWTON_ACRYLICS[i],p2=WINSOR_NEWTON_ACRYLICS[j],p3=WINSOR_NEWTON_ACRYLICS[k];
                [{r1:1,r2:1,r3:1},{r1:2,r2:1,r3:1},{r1:1,r2:2,r3:1},{r1:1,r2:1,r3:2}].forEach(r=>{
                    const m=mixThreeColors(p1,r.r1,p2,r.r2,p3,r.r3), d=colorDiff(targetRgb,m);
                    if(d<bestMatch.diff) bestMatch={paintNames:[p1.name,p2.name,p3.name],mixedRgb:m,diff:d,recipe:`${r.r1}p ${p1.name} + ${r.r2}p ${p2.name} + ${r.r3}p ${p3.name}`.replace(/1p/g, '1 part')};
                });
            }}}}
            return bestMatch;
        }
        function displayMixResult(mix) { /* ... */ if (!mix || !mix.mixedRgb) { mixingResult.innerHTML = '<p class="text-red-500">Could not find mix.</p>'; return; } let swHTML = ''; if (mix.paintNames) mix.paintNames.forEach(n => { const p = WINSOR_NEWTON_ACRYLICS.find(paint => paint.name === n); if (p) swHTML += `<span class="paint-swatch" style="background-color: rgb(${p.rgb.r},${p.rgb.g},${p.rgb.b});" title="${n}"></span>`; }); mixingResult.innerHTML = `<div class="flex items-center mb-3"><span class="color-swatch mr-3" style="background-color: rgb(${mix.mixedRgb.r},${mix.mixedRgb.g},${mix.mixedRgb.b});"></span><div><p class="font-semibold text-gray-800">Closest Mix (RGB: ${mix.mixedRgb.r},${mix.mixedRgb.g},${mix.mixedRgb.b})</p><p class="text-sm text-gray-600">Difference: ${mix.diff.toFixed(2)}</p></div></div><p class="text-gray-700 font-medium mb-1">Recipe:</p><div class="flex items-center mb-2">${swHTML}</div><p class="text-gray-700 bg-gray-100 p-2 rounded">${mix.recipe}</p>`;}

        // --- Utility Functions ---
        function componentToHex(c){const h=c.toString(16);return h.length==1?"0"+h:h;} function rgbToHex(r,g,b){return componentToHex(r)+componentToHex(g)+componentToHex(b);}
        function showLoadingModal(show){loadingModal.style.display=show?"block":"none";}
        function alertUser(message){let eM=document.getElementById('alertModal');if(eM)eM.remove();const aM=document.createElement('div');aM.id='alertModal';aM.className='modal';aM.style.display='block';const mC=document.createElement('div');mC.className='modal-content';const cB=document.createElement('span');cB.className='modal-close-button';cB.innerHTML='&times;';cB.onclick=()=>{aM.style.display='none';aM.remove();};const mP=document.createElement('p');mP.textContent=message;mP.className='text-gray-700 my-4';const oB=document.createElement('button');oB.textContent='OK';oB.className='bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-6 rounded-lg';oB.onclick=()=>{aM.style.display='none';aM.remove();};mC.appendChild(cB);mC.appendChild(mP);mC.appendChild(oB);aM.appendChild(mC);document.body.appendChild(aM);}
        function wrapText(ctx,text,x,y,maxW,lH){const w=text.split(' ');let l='';for(let i=0;i<w.length;i++){const tL=l+w[i]+' ';const mW=ctx.measureText(tL).width;if(mW>maxW&&i>0){ctx.fillText(l,x,y);l=w[i]+' ';y+=lH;}else{l=tL;}}ctx.fillText(l,x,y);}

        // Call on load
        drawInitialCanvasPlaceholder();

    </script>
</body>
</html>
